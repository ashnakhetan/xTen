{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to xTen!","text":""},{"location":"#steps","title":"Steps","text":"<pre><code>1. Run `pnpm install` in the plasmo project.\n2. Run `pnpm dev` in the plasmo project.\n3. Add the build folder as you would add any extension in chrome (we're literally only adding the extension here!)\n</code></pre> <p>If you look into the console of the extension you should see the test message show up!</p>"},{"location":"#later-steps","title":"Later steps","text":"<p>As we start adding packages to @xten, we're going to start getting our own dependencies so we will have to run <code>pnpm install</code> in that folder as well but for now we have nothing.</p>"},{"location":"#uploading-your-extension-to-chrome","title":"Uploading your Extension to Chrome","text":"<ol> <li>Head over to chrome://extensions and enable Developer Mode.</li> <li>Click on \"Load Unpacked\" and navigate to your extension's build/chrome-mv3-dev (or build/chrome-mv3-prod) directory.</li> <li>To see your popup, click on the puzzle piece icon on the Chrome toolbar, and click on your extension.</li> </ol>"},{"location":"#openai-notice","title":"OpenAI notice","text":"<p>Code added is server side so make sure to never ship any openai configs with it \u2013 devs would likely want to have a way for users to input their own key in and use that.</p>"},{"location":"outline/","title":"Software outline","text":"<p> xTen is a package that enables developers to create cross-platform browser extensions powered by AI. The toolkit provides an extensible architecture for integrating AI APIs, simplifying the development process and offering advanced features such as intelligent web scraping, code injection, and personalized suggestions. xTen consists of: 1. A JavaScript SDK with well-defined functions and methods for browser extension development. 2. Implement a plugin system with a clear API interface, documentation, and sample code.</p>"},{"location":"problem/","title":"Problem description and design criteria","text":"<p>With a sharp increase in AI-powered applications, there is need to develop tools that make the development pipeline easy. This is especially true in the case of browser extensions, where APIs like ChatGPT are used to create interactive tools.</p> <p>There is currently no clear and easy package that allows developers to easily integrate their preferred AI APIs into their browser extension workflows. This is the problem we are tackling -- our goals are listed below!</p> <ol> <li>Create a plugin system: Design our package with a plugin system that allows developers to easily integrate their preferred AI APIs. This can be achieved by defining a clear interface that plugins must implement to work with our package.</li> <li>Define the API interface: Clearly specify the methods and properties that AI plugins should expose. This will ensure a consistent integration experience for developers regardless of which AI API they use. For example, we might define methods for text analysis, image recognition, and machine learning tasks.</li> <li>Provide documentation and samples: Create comprehensive documentation on how to develop plugins for our package. Provide sample code for common AI APIs to guide developers in creating their own plugins. Encourage the developer community to contribute plugins for various AI APIs, expanding the package's compatibility.</li> <li>Build core features with plugin support: Develop the core features of our package (e.g., scraping, injecting code, and personalized suggestions) in a way that leverages the plugin system. This will allow developers to seamlessly integrate their AI API of choice while using your package's functionality.</li> <li>Ensure compatibility: While implementing the core features, we will make sure that they work well with different AI APIs by testing them with a variety of plugins. This will help us identify and address any compatibility issues.</li> <li>Encourage collaboration and contributions: Foster a community around our package that encourages developers to share their plugins, suggest improvements, and report any issues they encounter. This will help our package grow and improve over time!</li> </ol>"},{"location":"functions/scraper/","title":"Scraping information from webpages","text":"<p>This utility function allows you to scrape information of your choice from a site.</p> <p>Input: list of elements you wish to extract: Output: array of elements on page matching the input</p> <p>For example, if you want to extract:</p> <pre><code>Text: \u201ctitle\u201d, \u201ch1\u201d, \u201cp\u201d, \u201cul\u201d \u201col\u201d, \u201cli\u201d\nLinks: \u201ca\u201d\nImages: \u201cimg\u201d\nTables: \u201ctable\u201d, \u201ctr\u201d, \u201ctd\u201d\nForms: \u201cform\u201d, \u201cinput\u201d, \u201cselect\u201d, \u201ctextarea\u201d\nMetadata: \u201ctitle\u201d, \u201cmeta name=\u201ddescription\u201d\u201d, info in \u201chead\u201d\nSocial Media Embeds\nComments\nProduct information: might be something like \u201c'.product-price'\u201d\nStructured Data\n</code></pre> <p>Steps:</p> <ol> <li>Import the utility function</li> </ol> <pre><code>import { scrapePage } from '../@xten/src/utils/scrapePage';\n</code></pre> <ol> <li>Define a list of content types</li> </ol> <pre><code>const contentTypes = ['title, h1, h2, h3, h4'];\n</code></pre> <ol> <li>Then, in your app\u2019s function, you can call:</li> </ol> <pre><code>ScraperPlugin.scrape(contentTypes);\n</code></pre>"},{"location":"functions/summarize/","title":"Setting up and using the summarizer function(s)","text":"<p>scrape_summarize_data(): Scrape user-specified data from the page extract_user_profile(): Scrape a standard list of info from every page visited</p> <p>Steps:   1. Import summarizer plugin   <code>import {SummarizerPlugin } from '../@xten/src/plugins/summarizer/summarizerPlugin';</code></p> <ol> <li> <p>Paste in your API key and use the imported plugin   <code>const summarizerPlugin = new SummarizerPlugin(apiKey);</code></p> </li> <li> <p>Attach the imported plugin to the page   <code>summarizerPlugin.attach();</code></p> </li> </ol> <p>Almost done! Happy building :)</p>"},{"location":"functions/ui_injection/","title":"Injecting ui into webpages","text":"<p>Xten exports a class that handles injecting ui for you.</p> <p>To get started, you just need to call <code>xten.Injector</code> and export the relevant configs in <code>content.ts</code> like so:</p> <pre><code>const i = xten.Injector\n\nexport const config = (() =&gt; i.getConfig())()\nexport const getRootContainer = (() =&gt; i.getRootContainerConfig())()\nexport const render = (() =&gt; i.getRenderer())()\n</code></pre>"},{"location":"functions/ui_injection/#some-helpfeul-notes","title":"Some helpfeul notes:","text":"<ol> <li>You will need to configure which urls you'd want the injection to work on.</li> <li>Specify the container you'd like to replace.</li> <li>renderElem takes in react components! </li> </ol> <p>Example use case:</p> <pre><code>\nconst i = xten.Injector\n\n// configure url matches\ni.configure({\n  matches: [\"https://www.utu.fi/*\"]\n})\n\n// get root container by id\ni.injectById(\"block-herotitleblock\")\n\nconst PlasmoOverlay: FC&lt;PlasmoCSUIProps&gt; = () =&gt; {\n  return (\n    &lt;span\n      style={{\n        background: \"yellow\",\n        padding: 12\n      }}&gt;\n      HELLO WORLD ROOT CONTAINER\n    &lt;/span&gt;\n  )\n\n\n// inject element\ni.renderElem(&lt;PlasmoOverlay /&gt;)\n\nexport const config = (() =&gt; i.getConfig())()\nexport const getRootContainer = (() =&gt; i.getRootContainerConfig())()\nexport const render = (() =&gt; i.getRenderer())()\n\n</code></pre>"}]}